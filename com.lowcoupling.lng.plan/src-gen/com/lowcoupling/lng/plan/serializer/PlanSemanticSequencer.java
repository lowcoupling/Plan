/*
 * generated by Xtext
 */
package com.lowcoupling.lng.plan.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import com.lowcoupling.lng.plan.plan.Activity;
import com.lowcoupling.lng.plan.plan.ActivityGroup;
import com.lowcoupling.lng.plan.plan.Assumption;
import com.lowcoupling.lng.plan.plan.CheckPoint;
import com.lowcoupling.lng.plan.plan.Constraint;
import com.lowcoupling.lng.plan.plan.PlanImport;
import com.lowcoupling.lng.plan.plan.PlanPackage;
import com.lowcoupling.lng.plan.plan.Program;
import com.lowcoupling.lng.plan.plan.Project;
import com.lowcoupling.lng.plan.plan.Resource;
import com.lowcoupling.lng.plan.plan.ResourceInvolvement;
import com.lowcoupling.lng.plan.plan.Resources;
import com.lowcoupling.lng.plan.plan.ResourcesImport;
import com.lowcoupling.lng.plan.plan.WBSImport;
import com.lowcoupling.lng.plan.services.PlanGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class PlanSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PlanGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == PlanPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case PlanPackage.ACTIVITY:
				sequence_Activity(context, (Activity) semanticObject); 
				return; 
			case PlanPackage.ACTIVITY_GROUP:
				sequence_ActivityGroup(context, (ActivityGroup) semanticObject); 
				return; 
			case PlanPackage.ASSUMPTION:
				sequence_Assumption(context, (Assumption) semanticObject); 
				return; 
			case PlanPackage.CHECK_POINT:
				sequence_CheckPoint(context, (CheckPoint) semanticObject); 
				return; 
			case PlanPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case PlanPackage.PLAN_IMPORT:
				sequence_PlanImport(context, (PlanImport) semanticObject); 
				return; 
			case PlanPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case PlanPackage.PROJECT:
				sequence_Project(context, (Project) semanticObject); 
				return; 
			case PlanPackage.RESOURCE:
				sequence_Resource(context, (Resource) semanticObject); 
				return; 
			case PlanPackage.RESOURCE_INVOLVEMENT:
				sequence_ResourceInvolvement(context, (ResourceInvolvement) semanticObject); 
				return; 
			case PlanPackage.RESOURCES:
				sequence_Resources(context, (Resources) semanticObject); 
				return; 
			case PlanPackage.RESOURCES_IMPORT:
				sequence_ResourcesImport(context, (ResourcesImport) semanticObject); 
				return; 
			case PlanPackage.WBS_IMPORT:
				sequence_WBSImport(context, (WBSImport) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (description=ML_COMMENT? name=ID longName=STRING? dependencies+=[ActivityElement|QualifiedName]* activities+=ActivityElement*)
	 */
	protected void sequence_ActivityGroup(EObject context, ActivityGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         description=ML_COMMENT? 
	 *         name=ID 
	 *         longName=STRING? 
	 *         involvedResources+=ResourceInvolvement* 
	 *         (start=STRING | (after=[ActivityElement|QualifiedName] offset=INT)) 
	 *         (end=STRING | duration=INT) 
	 *         completeness=INT 
	 *         dependencies+=[ActivityElement|QualifiedName]*
	 *     )
	 */
	protected void sequence_Activity(EObject context, Activity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Assumption(EObject context, Assumption semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, PlanPackage.Literals.ASSUMPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PlanPackage.Literals.ASSUMPTION__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAssumptionAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         description=ML_COMMENT? 
	 *         name=ID 
	 *         longName=STRING? 
	 *         (end=STRING | (after=[ActivityElement|QualifiedName] offset=INT)) 
	 *         completeness=INT 
	 *         dependencies+=[ActivityElement|QualifiedName]*
	 *     )
	 */
	protected void sequence_CheckPoint(EObject context, CheckPoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Constraint(EObject context, Constraint semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, PlanPackage.Literals.CONSTRAINT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PlanPackage.Literals.CONSTRAINT__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConstraintAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_PlanImport(EObject context, PlanImport semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, PlanPackage.Literals.PLAN_IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PlanPackage.Literals.PLAN_IMPORT__IMPORT_URI));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPlanImportAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             description=ML_COMMENT? 
	 *             name=ID 
	 *             longName=STRING? 
	 *             plans+=PlanImport* 
	 *             referencedProjects+=[Project|QualifiedName]* 
	 *             projects+=Project*
	 *         ) | 
	 *         projects+=Project
	 *     )
	 */
	protected void sequence_Program(EObject context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         description=ML_COMMENT? 
	 *         name=ID 
	 *         longName=STRING? 
	 *         resources=Resources? 
	 *         plans+=PlanImport* 
	 *         assumptions+=Assumption* 
	 *         constraints+=Constraint* 
	 *         activities+=ActivityElement*
	 *     )
	 */
	protected void sequence_Project(EObject context, Project semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (resource=[Resource|ID] occupation=INT? responsibility=Responsibility?)
	 */
	protected void sequence_ResourceInvolvement(EObject context, ResourceInvolvement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_Resource(EObject context, Resource semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, PlanPackage.Literals.RESOURCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PlanPackage.Literals.RESOURCE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getResourceAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_ResourcesImport(EObject context, ResourcesImport semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, PlanPackage.Literals.RESOURCES_IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PlanPackage.Literals.RESOURCES_IMPORT__IMPORT_URI));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getResourcesImportAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     resource+=Resource*
	 */
	protected void sequence_Resources(EObject context, Resources semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_WBSImport(EObject context, WBSImport semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, PlanPackage.Literals.WBS_IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PlanPackage.Literals.WBS_IMPORT__IMPORT_URI));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWBSImportAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
}
